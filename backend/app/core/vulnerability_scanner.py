"""
Production-Ready Vulnerability Scanner Integration
Integrates with real security tools: Nuclei, Nmap, OWASP ZAP, etc.
"""
import os
import json
import subprocess
import asyncio
import tempfile
import re
import yaml
from typing import Dict, List, Optional, Any
from datetime import datetime
from pathlib import Path
import aiofiles
import httpx
from bs4 import BeautifulSoup
import nmap
import requests
from zapv2 import ZAPv2


class VulnerabilityScanner:
    """Main vulnerability scanner orchestrator"""

    def __init__(self):
        self.nuclei = NucleiScanner()
        self.nmap = NmapScanner()
        self.zap = ZAPScanner()
        self.custom = CustomVulnScanner()
        self.results = []

    async def scan_target(self, target: str, scan_type: str = "full") -> Dict:
        """
        Perform comprehensive vulnerability scan on target

        Args:
            target: Target URL, IP, or domain
            scan_type: Type of scan (full, quick, deep, custom)
        """
        scan_id = self._generate_scan_id()
        results = {
            "scan_id": scan_id,
            "target": target,
            "scan_type": scan_type,
            "started_at": datetime.utcnow().isoformat(),
            "vulnerabilities": [],
            "summary": {}
        }

        # Run different scanners based on scan type
        tasks = []

        if scan_type in ["full", "deep"]:
            tasks.append(self.nuclei.scan(target))
            tasks.append(self.nmap.scan(target))
            tasks.append(self.zap.scan(target))
            tasks.append(self.custom.scan(target))
        elif scan_type == "quick":
            tasks.append(self.nuclei.quick_scan(target))
            tasks.append(self.nmap.quick_scan(target))
        else:  # custom
            tasks.append(self.custom.scan(target))

        # Execute scans in parallel
        scan_results = await asyncio.gather(*tasks, return_exceptions=True)

        # Process and merge results
        for result in scan_results:
            if isinstance(result, Exception):
                print(f"Scan error: {result}")
                continue
            if result:
                results["vulnerabilities"].extend(result.get("vulnerabilities", []))

        # Generate summary
        results["summary"] = self._generate_summary(results["vulnerabilities"])
        results["completed_at"] = datetime.utcnow().isoformat()

        return results

    def _generate_scan_id(self) -> str:
        """Generate unique scan ID"""
        import uuid
        return f"scan_{uuid.uuid4().hex[:12]}"

    def _generate_summary(self, vulnerabilities: List) -> Dict:
        """Generate vulnerability summary statistics"""
        summary = {
            "total": len(vulnerabilities),
            "critical": 0,
            "high": 0,
            "medium": 0,
            "low": 0,
            "info": 0
        }

        for vuln in vulnerabilities:
            severity = vuln.get("severity", "info").lower()
            if severity in summary:
                summary[severity] += 1

        return summary


class NucleiScanner:
    """Nuclei vulnerability scanner integration"""

    def __init__(self):
        self.nuclei_path = "/usr/local/bin/nuclei"
        self.templates_path = "/opt/nuclei-templates"
        self.update_templates()

    def update_templates(self):
        """Update Nuclei templates to latest version"""
        try:
            subprocess.run([
                self.nuclei_path, "-ut"
            ], capture_output=True, timeout=60)
        except Exception as e:
            print(f"Failed to update Nuclei templates: {e}")

    async def scan(self, target: str, severity_filter: List[str] = None) -> Dict:
        """
        Run Nuclei scan on target

        Args:
            target: Target URL or domain
            severity_filter: List of severities to scan for
        """
        if severity_filter is None:
            severity_filter = ["critical", "high", "medium"]

        results = {
            "scanner": "nuclei",
            "vulnerabilities": []
        }

        try:
            # Create temporary output file
            with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as tmp:
                output_file = tmp.name

            # Build Nuclei command
            cmd = [
                self.nuclei_path,
                "-u", target,
                "-t", self.templates_path,
                "-severity", ",".join(severity_filter),
                "-json",
                "-o", output_file,
                "-rate-limit", "150",
                "-bulk-size", "25",
                "-concurrency", "25",
                "-timeout", "10",
                "-retries", "2",
                "-no-color",
                "-silent"
            ]

            # Execute Nuclei scan
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )

            stdout, stderr = await process.communicate()

            # Parse results
            if os.path.exists(output_file):
                async with aiofiles.open(output_file, 'r') as f:
                    content = await f.read()
                    for line in content.strip().split('\n'):
                        if line:
                            try:
                                finding = json.loads(line)
                                vulnerability = {
                                    "type": "nuclei",
                                    "template_id": finding.get("template-id"),
                                    "name": finding.get("info", {}).get("name"),
                                    "severity": finding.get("info", {}).get("severity"),
                                    "description": finding.get("info", {}).get("description"),
                                    "matched_at": finding.get("matched-at"),
                                    "matcher_name": finding.get("matcher-name"),
                                    "extracted_results": finding.get("extracted-results"),
                                    "curl_command": finding.get("curl-command"),
                                    "timestamp": finding.get("timestamp"),
                                    "tags": finding.get("info", {}).get("tags", []),
                                    "reference": finding.get("info", {}).get("reference", []),
                                    "cve_id": self._extract_cve(finding),
                                    "cvss_score": finding.get("info", {}).get("classification", {}).get("cvss-score"),
                                    "cwe_id": finding.get("info", {}).get("classification", {}).get("cwe-id")
                                }
                                results["vulnerabilities"].append(vulnerability)
                            except json.JSONDecodeError:
                                continue

                # Clean up
                os.unlink(output_file)

        except Exception as e:
            print(f"Nuclei scan error: {e}")

        return results

    async def quick_scan(self, target: str) -> Dict:
        """Quick scan with only critical and high severity templates"""
        return await self.scan(target, severity_filter=["critical", "high"])

    def _extract_cve(self, finding: Dict) -> Optional[str]:
        """Extract CVE ID from finding if present"""
        tags = finding.get("info", {}).get("tags", [])
        for tag in tags:
            if tag.startswith("cve"):
                return tag.upper()

        # Check in classification
        cve = finding.get("info", {}).get("classification", {}).get("cve-id")
        if cve:
            return f"CVE-{cve}" if not cve.startswith("CVE-") else cve

        return None


class NmapScanner:
    """Nmap network scanner integration"""

    def __init__(self):
        self.nm = nmap.PortScanner()

    async def scan(self, target: str) -> Dict:
        """
        Run comprehensive Nmap scan

        Args:
            target: Target IP or domain
        """
        results = {
            "scanner": "nmap",
            "vulnerabilities": []
        }

        try:
            # Run Nmap scan with vulnerability detection scripts
            self.nm.scan(
                target,
                arguments='-sV -sC -O -A --script vuln,exploit,auth,discovery'
            )

            for host in self.nm.all_hosts():
                if self.nm[host].state() == 'up':
                    # Process open ports
                    for proto in self.nm[host].all_protocols():
                        ports = self.nm[host][proto].keys()
                        for port in ports:
                            port_info = self.nm[host][proto][port]

                            # Check for vulnerabilities in scripts output
                            if 'script' in port_info:
                                for script_name, output in port_info['script'].items():
                                    if 'vuln' in script_name or 'exploit' in script_name:
                                        vulnerability = {
                                            "type": "nmap",
                                            "name": f"Vulnerable service on port {port}",
                                            "severity": self._determine_severity(script_name, output),
                                            "description": output,
                                            "port": port,
                                            "protocol": proto,
                                            "service": port_info.get('name', 'unknown'),
                                            "version": port_info.get('version', ''),
                                            "script": script_name,
                                            "host": host
                                        }
                                        results["vulnerabilities"].append(vulnerability)

                            # Check for weak service versions
                            if port_info.get('version'):
                                vuln = self._check_version_vulnerabilities(
                                    port_info.get('name'),
                                    port_info.get('version')
                                )
                                if vuln:
                                    vuln.update({
                                        "port": port,
                                        "protocol": proto,
                                        "host": host
                                    })
                                    results["vulnerabilities"].append(vuln)

        except Exception as e:
            print(f"Nmap scan error: {e}")

        return results

    async def quick_scan(self, target: str) -> Dict:
        """Quick port scan with basic vulnerability detection"""
        results = {
            "scanner": "nmap",
            "vulnerabilities": []
        }

        try:
            # Quick scan of top 1000 ports
            self.nm.scan(target, arguments='-sV -sC --top-ports 1000')

            for host in self.nm.all_hosts():
                if self.nm[host].state() == 'up':
                    for proto in self.nm[host].all_protocols():
                        ports = self.nm[host][proto].keys()
                        for port in ports:
                            port_info = self.nm[host][proto][port]
                            if port_info['state'] == 'open':
                                # Check for common vulnerable services
                                service = port_info.get('name', '')
                                if self._is_potentially_vulnerable(service, port):
                                    results["vulnerabilities"].append({
                                        "type": "nmap",
                                        "name": f"Potentially vulnerable service: {service}",
                                        "severity": "medium",
                                        "port": port,
                                        "service": service,
                                        "version": port_info.get('version', ''),
                                        "host": host
                                    })

        except Exception as e:
            print(f"Nmap quick scan error: {e}")

        return results

    def _determine_severity(self, script_name: str, output: str) -> str:
        """Determine vulnerability severity based on script output"""
        output_lower = output.lower()

        if 'critical' in output_lower or 'rce' in output_lower or 'remote code' in output_lower:
            return 'critical'
        elif 'high' in output_lower or 'exploit' in script_name:
            return 'high'
        elif 'medium' in output_lower or 'vuln' in script_name:
            return 'medium'
        elif 'low' in output_lower:
            return 'low'
        else:
            return 'info'

    def _check_version_vulnerabilities(self, service: str, version: str) -> Optional[Dict]:
        """Check if service version has known vulnerabilities"""
        # This would normally query a CVE database
        # For now, using basic pattern matching
        vulnerable_versions = {
            'ssh': ['1.', '2.', '3.', '4.'],  # Old SSH versions
            'apache': ['1.', '2.0', '2.2'],  # Old Apache versions
            'nginx': ['0.', '1.0', '1.1', '1.2'],  # Old nginx versions
            'mysql': ['3.', '4.', '5.0', '5.1'],  # Old MySQL versions
            'postgresql': ['7.', '8.', '9.0', '9.1', '9.2'],  # Old PostgreSQL
        }

        service_lower = service.lower()
        for vuln_service, vuln_versions in vulnerable_versions.items():
            if vuln_service in service_lower:
                for vuln_ver in vuln_versions:
                    if version.startswith(vuln_ver):
                        return {
                            "type": "nmap",
                            "name": f"Outdated {service} version",
                            "severity": "high",
                            "description": f"{service} version {version} is outdated and may contain vulnerabilities",
                            "service": service,
                            "version": version
                        }
        return None

    def _is_potentially_vulnerable(self, service: str, port: int) -> bool:
        """Check if service/port combination is potentially vulnerable"""
        vulnerable_services = {
            'telnet': True,
            'ftp': True,
            'vnc': True,
            'rdp': True,
            'smb': True,
            'netbios': True,
            'snmp': True,
            'ldap': True,
            'rpc': True,
            'nfs': True
        }

        dangerous_ports = [21, 23, 135, 137, 139, 445, 1433, 3306, 3389, 5900]

        service_lower = service.lower()
        for vuln_service in vulnerable_services:
            if vuln_service in service_lower:
                return True

        return port in dangerous_ports


class ZAPScanner:
    """OWASP ZAP scanner integration"""

    def __init__(self):
        self.api_key = os.getenv('ZAP_API_KEY', 'changeme')
        self.zap_url = 'http://localhost:8090'
        self.zap = None
        self._initialize_zap()

    def _initialize_zap(self):
        """Initialize ZAP API client"""
        try:
            self.zap = ZAPv2(apikey=self.api_key, proxies={'http': self.zap_url, 'https': self.zap_url})
        except Exception as e:
            print(f"Failed to initialize ZAP: {e}")

    async def scan(self, target: str) -> Dict:
        """
        Run OWASP ZAP scan on web application

        Args:
            target: Target URL
        """
        results = {
            "scanner": "zap",
            "vulnerabilities": []
        }

        if not self.zap:
            return results

        try:
            # Start new session
            self.zap.core.new_session()

            # Spider the target
            print(f"Spidering target: {target}")
            scan_id = self.zap.spider.scan(target)

            # Wait for spider to complete
            while int(self.zap.spider.status(scan_id)) < 100:
                await asyncio.sleep(2)

            # Start active scan
            print(f"Active scanning target: {target}")
            scan_id = self.zap.ascan.scan(target)

            # Wait for active scan to complete
            while int(self.zap.ascan.status(scan_id)) < 100:
                await asyncio.sleep(5)

            # Get alerts
            alerts = self.zap.core.alerts(baseurl=target)

            for alert in alerts:
                vulnerability = {
                    "type": "zap",
                    "name": alert.get('name'),
                    "severity": self._map_zap_severity(alert.get('risk')),
                    "description": alert.get('description'),
                    "solution": alert.get('solution'),
                    "reference": alert.get('reference'),
                    "cwe_id": f"CWE-{alert.get('cweid')}" if alert.get('cweid') else None,
                    "wasc_id": alert.get('wascid'),
                    "url": alert.get('url'),
                    "method": alert.get('method'),
                    "param": alert.get('param'),
                    "attack": alert.get('attack'),
                    "evidence": alert.get('evidence'),
                    "confidence": alert.get('confidence'),
                    "alert_ref": alert.get('alertRef'),
                    "tags": alert.get('tags', {})
                }
                results["vulnerabilities"].append(vulnerability)

        except Exception as e:
            print(f"ZAP scan error: {e}")

        return results

    def _map_zap_severity(self, risk: str) -> str:
        """Map ZAP risk levels to standard severity"""
        mapping = {
            'High': 'high',
            'Medium': 'medium',
            'Low': 'low',
            'Informational': 'info'
        }
        return mapping.get(risk, 'info')


class CustomVulnScanner:
    """Custom vulnerability checks for common security issues"""

    def __init__(self):
        self.checks = [
            self._check_security_headers,
            self._check_ssl_tls,
            self._check_exposed_files,
            self._check_common_vulns,
            self._check_misconfigurations
        ]

    async def scan(self, target: str) -> Dict:
        """Run custom vulnerability checks"""
        results = {
            "scanner": "custom",
            "vulnerabilities": []
        }

        tasks = [check(target) for check in self.checks]
        check_results = await asyncio.gather(*tasks, return_exceptions=True)

        for result in check_results:
            if isinstance(result, Exception):
                continue
            if result:
                results["vulnerabilities"].extend(result)

        return results

    async def _check_security_headers(self, target: str) -> List[Dict]:
        """Check for missing security headers"""
        vulnerabilities = []

        try:
            async with httpx.AsyncClient(verify=False, follow_redirects=True) as client:
                response = await client.get(target, timeout=10)
                headers = response.headers

                # Required security headers
                required_headers = {
                    'X-Frame-Options': 'Clickjacking protection',
                    'X-Content-Type-Options': 'MIME sniffing protection',
                    'Content-Security-Policy': 'XSS and injection protection',
                    'Strict-Transport-Security': 'HTTPS enforcement',
                    'X-XSS-Protection': 'XSS filter',
                    'Referrer-Policy': 'Referrer information control',
                    'Permissions-Policy': 'Browser features control'
                }

                for header, description in required_headers.items():
                    if header not in headers:
                        vulnerabilities.append({
                            "type": "custom",
                            "name": f"Missing security header: {header}",
                            "severity": "medium",
                            "description": f"The {header} header is missing. This header provides {description}.",
                            "solution": f"Add the {header} header to all HTTP responses.",
                            "url": target
                        })

        except Exception as e:
            print(f"Security headers check error: {e}")

        return vulnerabilities

    async def _check_ssl_tls(self, target: str) -> List[Dict]:
        """Check SSL/TLS configuration"""
        vulnerabilities = []

        try:
            from urllib.parse import urlparse
            parsed = urlparse(target)

            if parsed.scheme == 'http':
                vulnerabilities.append({
                    "type": "custom",
                    "name": "Unencrypted connection",
                    "severity": "high",
                    "description": "The application uses HTTP instead of HTTPS",
                    "solution": "Implement HTTPS with a valid SSL certificate",
                    "url": target
                })

            elif parsed.scheme == 'https':
                # Check SSL certificate
                import ssl
                import socket

                hostname = parsed.hostname
                port = parsed.port or 443

                context = ssl.create_default_context()
                with socket.create_connection((hostname, port), timeout=10) as sock:
                    with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                        cert = ssock.getpeercert()
                        cipher = ssock.cipher()

                        # Check cipher strength
                        if cipher and cipher[1] == 'TLSv1.0':
                            vulnerabilities.append({
                                "type": "custom",
                                "name": "Weak TLS version",
                                "severity": "medium",
                                "description": "Server supports TLS 1.0 which is deprecated",
                                "solution": "Disable TLS 1.0 and 1.1, use TLS 1.2 or higher",
                                "url": target
                            })

        except Exception as e:
            print(f"SSL/TLS check error: {e}")

        return vulnerabilities

    async def _check_exposed_files(self, target: str) -> List[Dict]:
        """Check for exposed sensitive files"""
        vulnerabilities = []

        sensitive_files = [
            '.git/config',
            '.env',
            '.env.local',
            '.env.production',
            'wp-config.php',
            'config.php',
            'database.yml',
            'secrets.yml',
            '.htaccess',
            'web.config',
            'phpinfo.php',
            'info.php',
            '.DS_Store',
            'Thumbs.db',
            'backup.sql',
            'dump.sql',
            'database.sql',
            '.bash_history',
            'id_rsa',
            'id_rsa.pub',
            'private.key',
            'server.key',
            '.aws/credentials',
            'firebase.json',
            'serviceAccountKey.json'
        ]

        async with httpx.AsyncClient(verify=False, follow_redirects=False) as client:
            for file in sensitive_files:
                try:
                    url = f"{target.rstrip('/')}/{file}"
                    response = await client.get(url, timeout=5)

                    if response.status_code == 200:
                        vulnerabilities.append({
                            "type": "custom",
                            "name": f"Exposed sensitive file: {file}",
                            "severity": "critical" if 'key' in file or 'password' in file else "high",
                            "description": f"Sensitive file {file} is publicly accessible",
                            "solution": f"Remove or restrict access to {file}",
                            "url": url
                        })

                except Exception:
                    continue

        return vulnerabilities

    async def _check_common_vulns(self, target: str) -> List[Dict]:
        """Check for common vulnerabilities"""
        vulnerabilities = []

        # SQL Injection test (basic)
        sql_payloads = ["'", '"', "' OR '1'='1", "1' OR 1=1--"]

        async with httpx.AsyncClient(verify=False, follow_redirects=True) as client:
            for payload in sql_payloads:
                try:
                    # Test in URL parameter
                    test_url = f"{target}?id={payload}"
                    response = await client.get(test_url, timeout=5)

                    # Look for SQL error messages
                    error_patterns = [
                        r"SQL syntax.*MySQL",
                        r"Warning.*mysql_",
                        r"valid MySQL result",
                        r"PostgreSQL.*ERROR",
                        r"Warning.*pg_",
                        r"Microsoft.*ODBC.*SQL Server",
                        r"Microsoft.*OLE DB.*SQL Server",
                        r"SQLite.*error",
                        r"ORA-[0-9]{5}",
                        r"Oracle.*error"
                    ]

                    for pattern in error_patterns:
                        if re.search(pattern, response.text, re.IGNORECASE):
                            vulnerabilities.append({
                                "type": "custom",
                                "name": "Potential SQL Injection",
                                "severity": "critical",
                                "description": f"SQL error detected with payload: {payload}",
                                "solution": "Use parameterized queries and input validation",
                                "url": test_url
                            })
                            break

                except Exception:
                    continue

        return vulnerabilities

    async def _check_misconfigurations(self, target: str) -> List[Dict]:
        """Check for common misconfigurations"""
        vulnerabilities = []

        # Check for directory listing
        async with httpx.AsyncClient(verify=False, follow_redirects=True) as client:
            try:
                response = await client.get(target, timeout=10)

                # Check for directory listing indicators
                if 'Index of /' in response.text or 'Directory listing' in response.text:
                    vulnerabilities.append({
                        "type": "custom",
                        "name": "Directory listing enabled",
                        "severity": "medium",
                        "description": "Web server is configured to show directory contents",
                        "solution": "Disable directory listing in web server configuration",
                        "url": target
                    })

                # Check for debug mode indicators
                debug_indicators = [
                    'DEBUG = True',
                    'debug_mode = true',
                    'WP_DEBUG',
                    'Symfony Debug',
                    'Laravel Debug',
                    'Django Debug',
                    'Application Trace',
                    'Stack Trace'
                ]

                for indicator in debug_indicators:
                    if indicator in response.text:
                        vulnerabilities.append({
                            "type": "custom",
                            "name": "Debug mode enabled",
                            "severity": "high",
                            "description": f"Application appears to be in debug mode: {indicator} found",
                            "solution": "Disable debug mode in production",
                            "url": target
                        })
                        break

            except Exception as e:
                print(f"Misconfiguration check error: {e}")

        return vulnerabilities


# Export scanner instance
vulnerability_scanner = VulnerabilityScanner()