from datetime import datetime
from typing import Dict, Any, List
import subprocess
import json
import os

from celery import current_task
from app.core.celery.celery_app import celery_app
from app.api.models.vulnerability import Vulnerability, VulnerabilityType, Severity
from app.core.logging import get_logger

logger = get_logger(__name__)


@celery_app.task(bind=True)
def vulnerability_scan_task(self, task_id: str, targets: List[str], config: Dict[str, Any]):
    """Execute vulnerability scanning task"""
    try:
        update_scan_progress(task_id, 0, "Starting vulnerability scan")

        results = {
            "vulnerabilities": [],
            "total_targets": len(targets),
            "processed": 0,
            "scanner": config.get("scanner", "nuclei")
        }

        scanner = config.get("scanner", "nuclei")

        for i, target in enumerate(targets):
            try:
                logger.info(f"Scanning target: {target} with {scanner}")

                if scanner == "nuclei":
                    vulns = scan_with_nuclei(target, config)
                elif scanner == "xray":
                    vulns = scan_with_xray(target, config)
                else:
                    vulns = []

                results["vulnerabilities"].extend(vulns)
                results["processed"] += 1

                # Update progress
                progress = int((i + 1) / len(targets) * 100)
                update_scan_progress(
                    task_id,
                    progress,
                    f"Scanned {i + 1}/{len(targets)} targets",
                    {"found_vulnerabilities": len(results["vulnerabilities"])}
                )

            except Exception as e:
                logger.error(f"Failed to scan {target}: {str(e)}")

        logger.info(f"Vulnerability scan completed: {len(results['vulnerabilities'])} vulnerabilities found")
        return results

    except Exception as e:
        logger.error(f"Vulnerability scan task failed: {str(e)}")
        raise


@celery_app.task(bind=True)
def vulnerability_verification_task(self, vulnerability_id: str, verification_config: Dict[str, Any]):
    """Verify a vulnerability"""
    try:
        logger.info(f"Verifying vulnerability: {vulnerability_id}")

        # Load vulnerability details (would need proper async handling)
        vulnerability_data = load_vulnerability(vulnerability_id)

        if not vulnerability_data:
            raise ValueError(f"Vulnerability {vulnerability_id} not found")

        # Perform verification based on vulnerability type
        verification_result = verify_vulnerability(vulnerability_data, verification_config)

        # Update vulnerability with verification result
        update_vulnerability_verification(vulnerability_id, verification_result)

        return verification_result

    except Exception as e:
        logger.error(f"Vulnerability verification failed: {str(e)}")
        raise


def scan_with_nuclei(target: str, config: Dict[str, Any]) -> List[Dict[str, Any]]:
    """Scan target using Nuclei"""
    vulnerabilities = []

    try:
        # Build nuclei command
        cmd = ["nuclei", "-target", target, "-json"]

        # Add severity filter
        if config.get("severity_filter"):
            cmd.extend(["-severity", ",".join(config["severity_filter"])])

        # Add template tags
        if config.get("tags"):
            cmd.extend(["-tags", ",".join(config["tags"])])

        # Execute nuclei
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            timeout=config.get("timeout", 600)
        )

        if result.returncode == 0:
            # Parse JSON output
            for line in result.stdout.strip().split('\n'):
                if line.strip():
                    try:
                        vuln_data = json.loads(line)
                        vulnerability = parse_nuclei_result(vuln_data, target)
                        if vulnerability:
                            vulnerabilities.append(vulnerability)
                    except json.JSONDecodeError:
                        continue

        else:
            logger.warning(f"Nuclei scan failed for {target}: {result.stderr}")

    except subprocess.TimeoutExpired:
        logger.warning(f"Nuclei scan timeout for {target}")
    except Exception as e:
        logger.error(f"Error running nuclei for {target}: {str(e)}")

    return vulnerabilities


def scan_with_xray(target: str, config: Dict[str, Any]) -> List[Dict[str, Any]]:
    """Scan target using Xray"""
    vulnerabilities = []

    try:
        # Build xray command
        cmd = ["xray", "webscan", "--basic-crawler", target]

        # Add configuration
        if config.get("xray_config"):
            cmd.extend(["--config", config["xray_config"]])

        # Execute xray
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            timeout=config.get("timeout", 900)
        )

        if result.returncode == 0:
            # Parse xray output (assuming JSON format)
            try:
                xray_results = json.loads(result.stdout)
                for vuln_data in xray_results.get("vulnerabilities", []):
                    vulnerability = parse_xray_result(vuln_data, target)
                    if vulnerability:
                        vulnerabilities.append(vulnerability)
            except json.JSONDecodeError:
                logger.warning("Failed to parse Xray output as JSON")

        else:
            logger.warning(f"Xray scan failed for {target}: {result.stderr}")

    except subprocess.TimeoutExpired:
        logger.warning(f"Xray scan timeout for {target}")
    except Exception as e:
        logger.error(f"Error running xray for {target}: {str(e)}")

    return vulnerabilities


def parse_nuclei_result(nuclei_data: Dict[str, Any], target: str) -> Dict[str, Any]:
    """Parse Nuclei result into vulnerability format"""
    try:
        # Map Nuclei severity to our severity enum
        severity_map = {
            "critical": Severity.CRITICAL,
            "high": Severity.HIGH,
            "medium": Severity.MEDIUM,
            "low": Severity.LOW,
            "info": Severity.INFO
        }

        severity = severity_map.get(
            nuclei_data.get("info", {}).get("severity", "").lower(),
            Severity.MEDIUM
        )

        # Determine vulnerability type based on tags
        vuln_type = determine_vulnerability_type(nuclei_data.get("info", {}).get("tags", []))

        vulnerability = {
            "title": nuclei_data.get("info", {}).get("name", "Unknown"),
            "description": nuclei_data.get("info", {}).get("description", ""),
            "vulnerability_type": vuln_type,
            "severity": severity,
            "target_url": nuclei_data.get("matched-at", target),
            "scanner": "nuclei",
            "template_id": nuclei_data.get("template-id"),
            "cve_id": extract_cve_from_tags(nuclei_data.get("info", {}).get("tags", [])),
            "evidence": {
                "request": nuclei_data.get("request", ""),
                "response": nuclei_data.get("response", ""),
                "matcher_name": nuclei_data.get("matcher-name", "")
            },
            "discovery_date": datetime.utcnow().isoformat()
        }

        return vulnerability

    except Exception as e:
        logger.error(f"Failed to parse Nuclei result: {str(e)}")
        return None


def parse_xray_result(xray_data: Dict[str, Any], target: str) -> Dict[str, Any]:
    """Parse Xray result into vulnerability format"""
    try:
        # Map Xray severity to our severity enum
        severity_map = {
            "critical": Severity.CRITICAL,
            "high": Severity.HIGH,
            "medium": Severity.MEDIUM,
            "low": Severity.LOW,
            "info": Severity.INFO
        }

        severity = severity_map.get(
            xray_data.get("detail", {}).get("level", "").lower(),
            Severity.MEDIUM
        )

        vulnerability = {
            "title": xray_data.get("plugin", "Unknown Vulnerability"),
            "description": xray_data.get("detail", {}).get("description", ""),
            "vulnerability_type": determine_xray_vulnerability_type(xray_data.get("plugin", "")),
            "severity": severity,
            "target_url": xray_data.get("target", {}).get("url", target),
            "scanner": "xray",
            "evidence": {
                "request": xray_data.get("detail", {}).get("request", ""),
                "response": xray_data.get("detail", {}).get("response", ""),
                "payload": xray_data.get("detail", {}).get("payload", "")
            },
            "discovery_date": datetime.utcnow().isoformat()
        }

        return vulnerability

    except Exception as e:
        logger.error(f"Failed to parse Xray result: {str(e)}")
        return None


def determine_vulnerability_type(tags: List[str]) -> VulnerabilityType:
    """Determine vulnerability type from Nuclei tags"""
    tag_mapping = {
        "sqli": VulnerabilityType.SQL_INJECTION,
        "xss": VulnerabilityType.XSS,
        "rce": VulnerabilityType.RCE,
        "lfi": VulnerabilityType.LFI,
        "ssrf": VulnerabilityType.SSRF,
        "xxe": VulnerabilityType.XXE,
        "csrf": VulnerabilityType.CSRF,
        "auth": VulnerabilityType.AUTHENTICATION_BYPASS,
        "disclosure": VulnerabilityType.INFORMATION_DISCLOSURE
    }

    for tag in tags:
        if tag.lower() in tag_mapping:
            return tag_mapping[tag.lower()]

    return VulnerabilityType.OTHER


def determine_xray_vulnerability_type(plugin_name: str) -> VulnerabilityType:
    """Determine vulnerability type from Xray plugin name"""
    plugin_mapping = {
        "sql": VulnerabilityType.SQL_INJECTION,
        "xss": VulnerabilityType.XSS,
        "cmd": VulnerabilityType.RCE,
        "path": VulnerabilityType.DIRECTORY_TRAVERSAL,
        "ssrf": VulnerabilityType.SSRF,
        "xxe": VulnerabilityType.XXE
    }

    plugin_lower = plugin_name.lower()
    for key, vuln_type in plugin_mapping.items():
        if key in plugin_lower:
            return vuln_type

    return VulnerabilityType.OTHER


def extract_cve_from_tags(tags: List[str]) -> str:
    """Extract CVE ID from Nuclei tags"""
    for tag in tags:
        if tag.startswith("cve-"):
            return tag.upper()
    return None


def verify_vulnerability(vulnerability_data: Dict[str, Any], config: Dict[str, Any]) -> Dict[str, Any]:
    """Verify a vulnerability"""
    result = {
        "verified": False,
        "verification_method": "manual",
        "notes": "",
        "verified_at": datetime.utcnow().isoformat()
    }

    try:
        # Implement verification logic based on vulnerability type
        vuln_type = vulnerability_data.get("vulnerability_type")

        if vuln_type == VulnerabilityType.SQL_INJECTION:
            result = verify_sql_injection(vulnerability_data, config)
        elif vuln_type == VulnerabilityType.XSS:
            result = verify_xss(vulnerability_data, config)
        # Add more verification methods as needed

    except Exception as e:
        logger.error(f"Verification failed: {str(e)}")
        result["notes"] = f"Verification failed: {str(e)}"

    return result


def verify_sql_injection(vulnerability_data: Dict[str, Any], config: Dict[str, Any]) -> Dict[str, Any]:
    """Verify SQL injection vulnerability"""
    # Implement SQL injection verification logic
    return {
        "verified": False,
        "verification_method": "automated",
        "notes": "SQL injection verification not implemented",
        "verified_at": datetime.utcnow().isoformat()
    }


def verify_xss(vulnerability_data: Dict[str, Any], config: Dict[str, Any]) -> Dict[str, Any]:
    """Verify XSS vulnerability"""
    # Implement XSS verification logic
    return {
        "verified": False,
        "verification_method": "automated",
        "notes": "XSS verification not implemented",
        "verified_at": datetime.utcnow().isoformat()
    }


def update_scan_progress(task_id: str, progress: int, message: str, metadata: Dict[str, Any] = None):
    """Update scan progress"""
    current_task.update_state(
        state="PROGRESS",
        meta={
            "progress": progress,
            "message": message,
            "metadata": metadata or {}
        }
    )


def load_vulnerability(vulnerability_id: str) -> Dict[str, Any]:
    """Load vulnerability from database"""
    # This would need proper async database access
    return {}


def update_vulnerability_verification(vulnerability_id: str, verification_result: Dict[str, Any]):
    """Update vulnerability with verification result"""
    # This would update the vulnerability in the database
    pass