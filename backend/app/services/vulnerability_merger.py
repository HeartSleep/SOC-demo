"""
Advanced Vulnerability Merger
Intelligently combines and deduplicates vulnerability findings from multiple sources
"""

from typing import List, Dict, Any, Set, Tuple, Optional
from dataclasses import dataclass, field
from datetime import datetime
import hashlib
import re


@dataclass
class VulnerabilityFingerprint:
    """Unique fingerprint for identifying duplicate vulnerabilities"""
    
    name_normalized: str
    host: str
    location: str = ""
    cve_id: Optional[str] = None
    cwe_id: Optional[str] = None
    severity: str = "unknown"
    
    def __hash__(self):
        return hash((
            self.name_normalized,
            self.host,
            self.location,
            self.cve_id or "",
            self.cwe_id or ""
        ))
    
    def __eq__(self, other):
        if not isinstance(other, VulnerabilityFingerprint):
            return False
        return (
            self.name_normalized == other.name_normalized
            and self.host == other.host
            and self.location == other.location
            and self.cve_id == other.cve_id
            and self.cwe_id == other.cwe_id
        )


@dataclass
class MergedVulnerability:
    """Represents a merged vulnerability with metadata from multiple sources"""
    
    vulnerability_data: Dict[str, Any]
    sources: List[str] = field(default_factory=list)
    confidence_score: float = 0.0
    detection_count: int = 1
    fingerprint: Optional[VulnerabilityFingerprint] = None
    first_detected: Optional[str] = None
    last_detected: Optional[str] = None


class VulnerabilityMerger:
    """
    Intelligently merges vulnerability findings from multiple scanning sources
    """
    
    # Severity ranking for prioritization (higher is more severe)
    SEVERITY_RANK = {
        "critical": 5,
        "high": 4,
        "medium": 3,
        "low": 2,
        "info": 1,
        "unknown": 0
    }
    
    # Source confidence weights (higher means more reliable)
    SOURCE_WEIGHTS = {
        "nuclei": 0.95,
        "zap": 0.90,
        "nmap": 0.85,
        "pattern_detection": 0.75,
        "custom": 0.70,
        "burp": 0.95,
        "default": 0.60
    }
    
    def __init__(self):
        self.merged_vulns: Dict[str, MergedVulnerability] = {}
    
    def normalize_name(self, name: str) -> str:
        """Normalize vulnerability name for comparison"""
        if not name:
            return ""
        
        # Convert to lowercase
        normalized = name.lower().strip()
        
        # Remove common prefixes/suffixes
        patterns_to_remove = [
            r'\[.*?\]',  # Remove bracketed text
            r'\(.*?\)',  # Remove parenthetical text
            r'vulnerability$',
            r'detected$',
            r'found$',
            r'^detected:\s*',
            r'^vulnerability:\s*',
        ]
        
        for pattern in patterns_to_remove:
            normalized = re.sub(pattern, '', normalized, flags=re.IGNORECASE)
        
        # Normalize whitespace
        normalized = ' '.join(normalized.split())
        
        return normalized
    
    def extract_cve_id(self, vuln: Dict[str, Any]) -> Optional[str]:
        """Extract CVE ID from vulnerability data"""
        # Check direct CVE field
        if vuln.get('cve_id'):
            return self.normalize_cve_id(vuln['cve_id'])
        
        # Check in tags
        tags = vuln.get('tags', [])
        if isinstance(tags, list):
            for tag in tags:
                if isinstance(tag, str) and tag.lower().startswith('cve'):
                    return self.normalize_cve_id(tag)
        
        # Check in references
        references = vuln.get('reference', [])
        if isinstance(references, list):
            for ref in references:
                if isinstance(ref, str) and 'cve' in ref.lower():
                    match = re.search(r'CVE-\d{4}-\d+', ref, re.IGNORECASE)
                    if match:
                        return match.group(0).upper()
        
        # Check in description or name
        for field in ['description', 'name', 'matched']:
            text = vuln.get(field, '')
            if isinstance(text, str):
                match = re.search(r'CVE-\d{4}-\d+', text, re.IGNORECASE)
                if match:
                    return match.group(0).upper()
        
        return None
    
    def extract_cwe_id(self, vuln: Dict[str, Any]) -> Optional[str]:
        """Extract CWE ID from vulnerability data"""
        # Check direct CWE field
        if vuln.get('cwe_id'):
            return self.normalize_cwe_id(vuln['cwe_id'])
        
        # Check in references
        references = vuln.get('reference', [])
        if isinstance(references, list):
            for ref in references:
                if isinstance(ref, str) and 'cwe' in ref.lower():
                    match = re.search(r'CWE-\d+', ref, re.IGNORECASE)
                    if match:
                        return match.group(0).upper()
        
        return None
    
    def normalize_cve_id(self, cve: str) -> str:
        """Normalize CVE ID format"""
        if not cve:
            return ""
        cve = cve.upper().strip()
        if not cve.startswith('CVE-'):
            cve = f'CVE-{cve}'
        return cve
    
    def normalize_cwe_id(self, cwe: str) -> str:
        """Normalize CWE ID format"""
        if not cwe:
            return ""
        cwe = cwe.upper().strip()
        if not cwe.startswith('CWE-'):
            cwe = f'CWE-{cwe}'
        return cwe
    
    def create_fingerprint(self, vuln: Dict[str, Any]) -> VulnerabilityFingerprint:
        """Create a unique fingerprint for a vulnerability"""
        name = vuln.get('name', vuln.get('template', 'unknown'))
        host = vuln.get('host', vuln.get('target', ''))
        
        # Extract location information
        location_parts = []
        for field in ['path', 'url', 'matched', 'port']:
            value = vuln.get(field)
            if value:
                location_parts.append(str(value)[:100])  # Limit length
        location = '|'.join(location_parts)
        
        return VulnerabilityFingerprint(
            name_normalized=self.normalize_name(name),
            host=host,
            location=location,
            cve_id=self.extract_cve_id(vuln),
            cwe_id=self.extract_cwe_id(vuln),
            severity=vuln.get('severity', 'unknown').lower()
        )
    
    def calculate_similarity_score(
        self,
        fp1: VulnerabilityFingerprint,
        fp2: VulnerabilityFingerprint
    ) -> float:
        """Calculate similarity score between two vulnerability fingerprints"""
        score = 0.0
        
        # Exact matches are worth more
        if fp1.cve_id and fp2.cve_id and fp1.cve_id == fp2.cve_id:
            score += 0.4
        
        if fp1.cwe_id and fp2.cwe_id and fp1.cwe_id == fp2.cwe_id:
            score += 0.2
        
        if fp1.host == fp2.host:
            score += 0.2
        
        # Name similarity
        if fp1.name_normalized == fp2.name_normalized:
            score += 0.3
        elif fp1.name_normalized in fp2.name_normalized or fp2.name_normalized in fp1.name_normalized:
            score += 0.15
        
        # Location similarity
        if fp1.location and fp2.location:
            if fp1.location == fp2.location:
                score += 0.2
            elif fp1.location in fp2.location or fp2.location in fp1.location:
                score += 0.1
        
        return min(score, 1.0)
    
    def calculate_confidence_score(
        self,
        merged_vuln: MergedVulnerability
    ) -> float:
        """Calculate confidence score for a merged vulnerability"""
        base_score = 0.0
        
        # Multiple sources increase confidence
        if merged_vuln.detection_count > 1:
            base_score += 0.2 * min(merged_vuln.detection_count - 1, 3)
        
        # High-confidence sources
        for source in merged_vuln.sources:
            source_weight = self.SOURCE_WEIGHTS.get(source, self.SOURCE_WEIGHTS['default'])
            base_score += source_weight * 0.2
        
        # CVE/CWE identification increases confidence
        vuln_data = merged_vuln.vulnerability_data
        if self.extract_cve_id(vuln_data):
            base_score += 0.15
        if self.extract_cwe_id(vuln_data):
            base_score += 0.10
        
        # Severity alignment
        severity = vuln_data.get('severity', 'unknown').lower()
        if severity in ['critical', 'high']:
            base_score += 0.05
        
        return min(base_score, 1.0)
    
    def merge_vulnerability_data(
        self,
        existing: Dict[str, Any],
        incoming: Dict[str, Any],
        existing_source: str,
        incoming_source: str
    ) -> Dict[str, Any]:
        """Merge two vulnerability data dictionaries intelligently"""
        merged = existing.copy()
        
        # Prefer higher severity
        existing_severity = existing.get('severity', 'unknown').lower()
        incoming_severity = incoming.get('severity', 'unknown').lower()
        
        existing_rank = self.SEVERITY_RANK.get(existing_severity, 0)
        incoming_rank = self.SEVERITY_RANK.get(incoming_severity, 0)
        
        if incoming_rank > existing_rank:
            merged['severity'] = incoming['severity']
        
        # Merge descriptions
        existing_desc = existing.get('description', '')
        incoming_desc = incoming.get('description', '')
        if incoming_desc and incoming_desc not in existing_desc:
            if existing_desc:
                merged['description'] = f"{existing_desc}\n\nAdditional info from {incoming_source}: {incoming_desc}"
            else:
                merged['description'] = incoming_desc
        
        # Combine references
        existing_refs = existing.get('reference', [])
        incoming_refs = incoming.get('reference', [])
        if not isinstance(existing_refs, list):
            existing_refs = [existing_refs] if existing_refs else []
        if not isinstance(incoming_refs, list):
            incoming_refs = [incoming_refs] if incoming_refs else []
        
        all_refs = list(set(existing_refs + incoming_refs))
        if all_refs:
            merged['reference'] = all_refs
        
        # Combine tags
        existing_tags = existing.get('tags', [])
        incoming_tags = incoming.get('tags', [])
        if not isinstance(existing_tags, list):
            existing_tags = [existing_tags] if existing_tags else []
        if not isinstance(incoming_tags, list):
            incoming_tags = [incoming_tags] if incoming_tags else []
        
        all_tags = list(set(existing_tags + incoming_tags))
        if all_tags:
            merged['tags'] = all_tags
        
        # Prefer CVE/CWE from higher confidence source
        incoming_weight = self.SOURCE_WEIGHTS.get(incoming_source, self.SOURCE_WEIGHTS['default'])
        existing_weight = self.SOURCE_WEIGHTS.get(existing_source, self.SOURCE_WEIGHTS['default'])
        
        if incoming_weight > existing_weight:
            for field in ['cve_id', 'cwe_id', 'cvss_score']:
                if incoming.get(field) and not existing.get(field):
                    merged[field] = incoming[field]
        
        # Keep more detailed matched location
        existing_matched = len(str(existing.get('matched', '')))
        incoming_matched = len(str(incoming.get('matched', '')))
        if incoming_matched > existing_matched:
            merged['matched'] = incoming['matched']
        
        # Preserve remediation info from any source
        if incoming.get('remediation') and not existing.get('remediation'):
            merged['remediation'] = incoming['remediation']
        
        if incoming.get('solution') and not existing.get('solution'):
            merged['solution'] = incoming['solution']
        
        return merged
    
    def add_vulnerability(
        self,
        vuln: Dict[str, Any],
        source: str,
        timestamp: Optional[str] = None
    ) -> str:
        """
        Add a vulnerability to the merger
        Returns: fingerprint key for the vulnerability
        """
        if timestamp is None:
            timestamp = datetime.utcnow().isoformat()
        
        fingerprint = self.create_fingerprint(vuln)
        fp_key = str(hash(fingerprint))
        
        # Check for exact match
        if fp_key in self.merged_vulns:
            existing = self.merged_vulns[fp_key]
            
            # Update vulnerability data with intelligent merge
            primary_source = existing.sources[0] if existing.sources else 'unknown'
            existing.vulnerability_data = self.merge_vulnerability_data(
                existing.vulnerability_data,
                vuln,
                primary_source,
                source
            )
            
            # Update metadata
            if source not in existing.sources:
                existing.sources.append(source)
            existing.detection_count += 1
            existing.last_detected = timestamp
            
            # Recalculate confidence
            existing.confidence_score = self.calculate_confidence_score(existing)
            
            return fp_key
        
        # Check for similar vulnerabilities (fuzzy matching)
        for existing_fp_key, existing_merged in self.merged_vulns.items():
            if existing_merged.fingerprint:
                similarity = self.calculate_similarity_score(
                    fingerprint,
                    existing_merged.fingerprint
                )
                
                # If similarity is high enough, merge
                if similarity >= 0.7:
                    primary_source = existing_merged.sources[0] if existing_merged.sources else 'unknown'
                    existing_merged.vulnerability_data = self.merge_vulnerability_data(
                        existing_merged.vulnerability_data,
                        vuln,
                        primary_source,
                        source
                    )
                    
                    if source not in existing_merged.sources:
                        existing_merged.sources.append(source)
                    existing_merged.detection_count += 1
                    existing_merged.last_detected = timestamp
                    existing_merged.confidence_score = self.calculate_confidence_score(existing_merged)
                    
                    return existing_fp_key
        
        # No match found, create new entry
        merged_vuln = MergedVulnerability(
            vulnerability_data=vuln.copy(),
            sources=[source],
            fingerprint=fingerprint,
            first_detected=timestamp,
            last_detected=timestamp
        )
        merged_vuln.confidence_score = self.calculate_confidence_score(merged_vuln)
        
        self.merged_vulns[fp_key] = merged_vuln
        
        return fp_key
    
    def get_merged_vulnerabilities(
        self,
        min_confidence: float = 0.0,
        sort_by: str = 'severity'
    ) -> List[Dict[str, Any]]:
        """
        Get all merged vulnerabilities with metadata
        
        Args:
            min_confidence: Minimum confidence score to include
            sort_by: Field to sort by ('severity', 'confidence', 'detection_count')
        """
        results = []
        
        for merged in self.merged_vulns.values():
            if merged.confidence_score < min_confidence:
                continue
            
            vuln_data = merged.vulnerability_data.copy()
            
            # Add merger metadata
            vuln_data['merger_metadata'] = {
                'sources': merged.sources,
                'confidence_score': round(merged.confidence_score, 3),
                'detection_count': merged.detection_count,
                'first_detected': merged.first_detected,
                'last_detected': merged.last_detected
            }
            
            results.append(vuln_data)
        
        # Sort results
        if sort_by == 'severity':
            results.sort(
                key=lambda v: self.SEVERITY_RANK.get(
                    v.get('severity', 'unknown').lower(),
                    0
                ),
                reverse=True
            )
        elif sort_by == 'confidence':
            results.sort(
                key=lambda v: v.get('merger_metadata', {}).get('confidence_score', 0),
                reverse=True
            )
        elif sort_by == 'detection_count':
            results.sort(
                key=lambda v: v.get('merger_metadata', {}).get('detection_count', 0),
                reverse=True
            )
        
        return results
    
    def get_statistics(self) -> Dict[str, Any]:
        """Get statistics about merged vulnerabilities"""
        total = len(self.merged_vulns)
        
        by_severity = {}
        by_source = {}
        multi_source = 0
        
        for merged in self.merged_vulns.values():
            severity = merged.vulnerability_data.get('severity', 'unknown').lower()
            by_severity[severity] = by_severity.get(severity, 0) + 1
            
            if merged.detection_count > 1:
                multi_source += 1
            
            for source in merged.sources:
                by_source[source] = by_source.get(source, 0) + 1
        
        avg_confidence = sum(
            m.confidence_score for m in self.merged_vulns.values()
        ) / total if total > 0 else 0.0
        
        return {
            'total_unique_vulnerabilities': total,
            'by_severity': by_severity,
            'by_source': by_source,
            'multi_source_detections': multi_source,
            'average_confidence_score': round(avg_confidence, 3),
            'deduplication_rate': round(
                (multi_source / total * 100) if total > 0 else 0,
                2
            )
        }
