from datetime import datetime
from typing import Optional, List, Dict, Any
from sqlalchemy import Column, String, Boolean, DateTime, Integer, Float, Enum as SQLEnum, JSON, Index, Text
from sqlalchemy.dialects.postgresql import UUID, ARRAY
from app.core.database import Base
import uuid
import enum


class VulnerabilityType(str, enum.Enum):
    SQL_INJECTION = "sql_injection"
    XSS = "xss"
    CSRF = "csrf"
    XXE = "xxe"
    SSRF = "ssrf"
    RCE = "rce"
    LFI = "lfi"
    RFI = "rfi"
    DIRECTORY_TRAVERSAL = "directory_traversal"
    AUTHENTICATION_BYPASS = "authentication_bypass"
    AUTHORIZATION_BYPASS = "authorization_bypass"
    INFORMATION_DISCLOSURE = "information_disclosure"
    WEAK_CONFIGURATION = "weak_configuration"
    OUTDATED_SOFTWARE = "outdated_software"
    WEAK_CREDENTIALS = "weak_credentials"
    OPEN_PORTS = "open_ports"
    SSL_ISSUES = "ssl_issues"
    DNS_ISSUES = "dns_issues"
    OTHER = "other"


class Severity(str, enum.Enum):
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"


class VulnerabilityStatus(str, enum.Enum):
    OPEN = "open"
    CONFIRMED = "confirmed"
    FALSE_POSITIVE = "false_positive"
    RISK_ACCEPTED = "risk_accepted"
    FIXED = "fixed"
    RETEST_REQUIRED = "retest_required"
    CLOSED = "closed"


class Vulnerability(Base):
    __tablename__ = "vulnerabilities"

    # Primary Key
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4, index=True)

    # Basic info
    title = Column(String(500), nullable=False)
    description = Column(Text, nullable=False)
    vulnerability_type = Column(SQLEnum(VulnerabilityType), nullable=False, index=True)
    severity = Column(SQLEnum(Severity), nullable=False, index=True)
    status = Column(SQLEnum(VulnerabilityStatus), default=VulnerabilityStatus.OPEN, nullable=False, index=True)

    # Target information
    target_asset_id = Column(UUID(as_uuid=True), nullable=False, index=True)
    target_url = Column(Text, nullable=True)
    target_ip = Column(String(45), nullable=True)
    target_port = Column(Integer, nullable=True)
    target_path = Column(Text, nullable=True)

    # Technical details
    cve_id = Column(String(50), nullable=True, index=True)
    cwe_id = Column(String(50), nullable=True)
    cvss_score = Column(Float, nullable=True)
    cvss_vector = Column(String(255), nullable=True)

    # Discovery information
    scanner = Column(String(100), nullable=False, index=True)
    scan_task_id = Column(UUID(as_uuid=True), nullable=True)
    discovery_date = Column(DateTime, default=datetime.utcnow, nullable=False, index=True)

    # Evidence
    request = Column(Text, nullable=True)
    response = Column(Text, nullable=True)
    payload = Column(Text, nullable=True)
    proof_of_concept = Column(Text, nullable=True)
    screenshots = Column(ARRAY(String), server_default='{}', nullable=False)
    evidence_files = Column(ARRAY(String), server_default='{}', nullable=False)

    # Impact assessment
    impact_description = Column(Text, nullable=True)
    business_impact = Column(Text, nullable=True)
    affected_systems = Column(ARRAY(String), server_default='{}', nullable=False)

    # Remediation
    remediation_advice = Column(Text, nullable=True)
    remediation_priority = Column(String(20), default="medium", nullable=False)
    fix_complexity = Column(String(20), default="medium", nullable=False)
    estimated_fix_time = Column(Integer, nullable=True)  # hours

    # Verification
    verified = Column(Boolean, default=False, nullable=False)
    verified_by = Column(UUID(as_uuid=True), nullable=True)
    verified_at = Column(DateTime, nullable=True)
    verification_notes = Column(Text, nullable=True)

    # Tracking
    assigned_to = Column(UUID(as_uuid=True), nullable=True, index=True)
    due_date = Column(DateTime, nullable=True)
    sla_breach = Column(Boolean, default=False, nullable=False)

    # Communication
    reported_to = Column(ARRAY(String), server_default='{}', nullable=False)
    comments = Column(JSON, server_default='[]', nullable=False)

    # Audit fields
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False, index=True)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, nullable=False)
    created_by = Column(UUID(as_uuid=True), nullable=False, index=True)
    updated_by = Column(UUID(as_uuid=True), nullable=True)

    # Retest information
    retest_count = Column(Integer, default=0, nullable=False)
    last_retest = Column(DateTime, nullable=True)
    retest_results = Column(JSON, server_default='[]', nullable=False)

    # Tags and metadata
    tags = Column(ARRAY(String), server_default='{}', nullable=False)
    custom_fields = Column(JSON, server_default='{}', nullable=False)
    references = Column(ARRAY(String), server_default='{}', nullable=False)

    # Scoring
    exploitability = Column(Float, nullable=True)
    remediation_level = Column(Float, nullable=True)
    report_confidence = Column(Float, nullable=True)

    # Indexes
    __table_args__ = (
        Index('idx_vuln_target_asset', 'target_asset_id'),
        Index('idx_vuln_type', 'vulnerability_type'),
        Index('idx_vuln_severity', 'severity'),
        Index('idx_vuln_status', 'status'),
        Index('idx_vuln_scanner', 'scanner'),
        Index('idx_vuln_discovery_date', 'discovery_date'),
        Index('idx_vuln_created_by', 'created_by'),
        Index('idx_vuln_assigned_to', 'assigned_to'),
        Index('idx_vuln_cve_id', 'cve_id'),
    )

    def calculate_risk_score(self) -> float:
        severity_weights = {
            Severity.CRITICAL: 10.0,
            Severity.HIGH: 7.5,
            Severity.MEDIUM: 5.0,
            Severity.LOW: 2.5,
            Severity.INFO: 0.5
        }

        base_score = severity_weights.get(self.severity, 5.0)

        if self.cvss_score:
            return self.cvss_score

        return base_score

    def get_age_days(self) -> int:
        return (datetime.utcnow() - self.discovery_date).days

    def is_overdue(self) -> bool:
        if self.due_date:
            return datetime.utcnow() > self.due_date
        return False