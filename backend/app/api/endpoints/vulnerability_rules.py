"""
Vulnerability Rules API Endpoints
Provides endpoints for managing and accessing vulnerability detection rules
"""

from fastapi import APIRouter, HTTPException, Query
from typing import List, Dict, Any, Optional
from app.services.vulnerability_rules import VulnerabilityDetector, VulnerabilityCategory, Severity
from app.core.logging import get_logger
from pydantic import BaseModel

logger = get_logger(__name__)
router = APIRouter()

# Initialize detector
detector = VulnerabilityDetector()


class TestPatternRequest(BaseModel):
    """Request body for testing patterns"""
    content: str
    rule_ids: Optional[List[str]] = None
    categories: Optional[List[str]] = None


class RuleUpdateRequest(BaseModel):
    """Request body for updating rules"""
    enabled: Optional[bool] = None
    severity: Optional[str] = None
    confidence_threshold: Optional[float] = None


@router.get("/")
async def list_rules(
    category: Optional[str] = Query(None, description="Filter by category"),
    severity: Optional[str] = Query(None, description="Filter by severity"),
    search: Optional[str] = Query(None, description="Search in rule names and descriptions"),
    enabled_only: bool = Query(True, description="Show only enabled rules")
):
    """Get all vulnerability detection rules"""

    rules = []
    for rule in detector.rules:
        # Convert rule to dict
        rule_dict = {
            "id": rule.id,
            "name": rule.name,
            "description": rule.description,
            "category": rule.category.value,
            "severity": rule.severity.value,
            "pattern": rule.pattern,
            "cwe_id": rule.cwe_id,
            "owasp_category": rule.owasp_category,
            "remediation": rule.remediation,
            "enabled": rule.enabled,
            "confidence_threshold": rule.confidence_threshold
        }

        # Apply filters
        if category and rule.category.value != category:
            continue
        if severity and rule.severity.value != severity:
            continue
        if enabled_only and not rule.enabled:
            continue
        if search:
            search_lower = search.lower()
            if (search_lower not in rule.name.lower() and
                search_lower not in rule.description.lower()):
                continue

        rules.append(rule_dict)

    return {
        "rules": rules,
        "total": len(rules),
        "categories": [cat.value for cat in VulnerabilityCategory],
        "severities": [sev.value for sev in Severity]
    }


@router.get("/categories")
async def get_categories():
    """Get all vulnerability categories with rule counts"""

    category_stats = {}
    for rule in detector.rules:
        cat = rule.category.value
        if cat not in category_stats:
            category_stats[cat] = {
                "name": cat,
                "count": 0,
                "enabled_count": 0,
                "severities": {}
            }

        category_stats[cat]["count"] += 1
        if rule.enabled:
            category_stats[cat]["enabled_count"] += 1

        severity = rule.severity.value
        if severity not in category_stats[cat]["severities"]:
            category_stats[cat]["severities"][severity] = 0
        category_stats[cat]["severities"][severity] += 1

    return list(category_stats.values())


@router.get("/statistics")
async def get_rule_statistics():
    """Get vulnerability rule statistics"""

    stats = {
        "total_rules": len(detector.rules),
        "enabled_rules": sum(1 for r in detector.rules if r.enabled),
        "disabled_rules": sum(1 for r in detector.rules if not r.enabled),
        "by_severity": {},
        "by_category": {},
        "by_owasp": {}
    }

    for rule in detector.rules:
        # Count by severity
        severity = rule.severity.value
        if severity not in stats["by_severity"]:
            stats["by_severity"][severity] = 0
        stats["by_severity"][severity] += 1

        # Count by category
        category = rule.category.value
        if category not in stats["by_category"]:
            stats["by_category"][category] = 0
        stats["by_category"][category] += 1

        # Count by OWASP category
        owasp = rule.owasp_category
        if owasp and owasp not in stats["by_owasp"]:
            stats["by_owasp"][owasp] = 0
        if owasp:
            stats["by_owasp"][owasp] += 1

    return stats


@router.get("/{rule_id}")
async def get_rule(rule_id: str):
    """Get a specific vulnerability rule by ID"""

    for rule in detector.rules:
        if rule.id == rule_id:
            return {
                "id": rule.id,
                "name": rule.name,
                "description": rule.description,
                "category": rule.category.value,
                "severity": rule.severity.value,
                "pattern": rule.pattern,
                "cwe_id": rule.cwe_id,
                "owasp_category": rule.owasp_category,
                "remediation": rule.remediation,
                "enabled": rule.enabled,
                "confidence_threshold": rule.confidence_threshold,
                "examples": getattr(rule, 'examples', [])
            }

    raise HTTPException(status_code=404, detail=f"Rule {rule_id} not found")


@router.post("/test")
async def test_patterns(request: TestPatternRequest):
    """Test vulnerability detection patterns against provided content"""

    # Filter rules based on request
    rules_to_test = detector.rules

    if request.rule_ids:
        rules_to_test = [r for r in rules_to_test if r.id in request.rule_ids]

    if request.categories:
        rules_to_test = [r for r in rules_to_test if r.category.value in request.categories]

    # Temporarily set rules for testing
    original_rules = detector.rules
    detector.rules = rules_to_test

    # Scan content
    vulnerabilities = detector.scan_content(request.content, context="Test Pattern")

    # Restore original rules
    detector.rules = original_rules

    return {
        "content_length": len(request.content),
        "rules_tested": len(rules_to_test),
        "vulnerabilities_found": len(vulnerabilities),
        "vulnerabilities": vulnerabilities
    }


@router.put("/{rule_id}")
async def update_rule(rule_id: str, request: RuleUpdateRequest):
    """Update a vulnerability rule's settings"""

    for rule in detector.rules:
        if rule.id == rule_id:
            if request.enabled is not None:
                rule.enabled = request.enabled
            if request.severity is not None:
                try:
                    rule.severity = Severity[request.severity.upper()]
                except KeyError:
                    raise HTTPException(status_code=400, detail=f"Invalid severity: {request.severity}")
            if request.confidence_threshold is not None:
                rule.confidence_threshold = request.confidence_threshold

            return {
                "message": f"Rule {rule_id} updated successfully",
                "rule": {
                    "id": rule.id,
                    "name": rule.name,
                    "enabled": rule.enabled,
                    "severity": rule.severity.value,
                    "confidence_threshold": rule.confidence_threshold
                }
            }

    raise HTTPException(status_code=404, detail=f"Rule {rule_id} not found")


@router.post("/bulk-update")
async def bulk_update_rules(
    category: Optional[str] = None,
    severity: Optional[str] = None,
    enabled: Optional[bool] = None
):
    """Bulk update rules based on filters"""

    updated_count = 0

    for rule in detector.rules:
        should_update = True

        # Check if rule matches filters
        if category and rule.category.value != category:
            should_update = False
        if severity and rule.severity.value != severity:
            should_update = False

        # Update if matches
        if should_update and enabled is not None:
            rule.enabled = enabled
            updated_count += 1

    return {
        "message": f"Updated {updated_count} rules",
        "updated_count": updated_count
    }


@router.get("/export/nuclei-templates")
async def export_as_nuclei_templates():
    """Export vulnerability rules as Nuclei template suggestions"""

    templates = []

    for rule in detector.rules:
        if rule.enabled:
            template = {
                "id": rule.id.lower().replace("-", "_"),
                "name": rule.name,
                "description": rule.description,
                "severity": rule.severity.value,
                "tags": [rule.category.value, f"cwe-{rule.cwe_id}"],
                "reference": [
                    f"https://cwe.mitre.org/data/definitions/{rule.cwe_id}.html"
                ],
                "matchers": [
                    {
                        "type": "regex",
                        "regex": [rule.pattern]
                    }
                ],
                "metadata": {
                    "owasp": rule.owasp_category,
                    "remediation": rule.remediation
                }
            }
            templates.append(template)

    return {
        "templates": templates,
        "total": len(templates),
        "note": "These are template suggestions. Review and adapt them for Nuclei before use."
    }


@router.get("/search/{query}")
async def search_rules(query: str):
    """Search vulnerability rules by pattern or content"""

    query_lower = query.lower()
    matching_rules = []

    for rule in detector.rules:
        # Search in various fields
        if (query_lower in rule.name.lower() or
            query_lower in rule.description.lower() or
            query_lower in rule.pattern.lower() or
            query_lower in rule.remediation.lower() or
            query_lower in str(rule.cwe_id).lower() or
            (rule.owasp_category and query_lower in rule.owasp_category.lower())):

            matching_rules.append({
                "id": rule.id,
                "name": rule.name,
                "description": rule.description,
                "category": rule.category.value,
                "severity": rule.severity.value,
                "match_preview": rule.pattern[:100] + "..." if len(rule.pattern) > 100 else rule.pattern
            })

    return {
        "query": query,
        "results": matching_rules,
        "count": len(matching_rules)
    }